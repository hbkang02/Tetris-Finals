{"ast":null,"code":"export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\nexport const createStage = () => Array.from(Array(STAGE_HEIGHT), () => new Array(STAGE_WIDTH).fill([0, \"clear\"]));\nexport const checkCollision = (player, stage, _ref) => {\n  let {\n    x: moveX,\n    y: moveY\n  } = _ref;\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n        // 2. Check that our move is inside the game areas height (y)\n        // we shouldn't go through the bottom of the play area\n        !stage[y + player.pos.y + moveY] ||\n        // 3. Check that our move is inside the game areas width (x)\n        !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n        // 4. Check that the cell we're moving to isn't set to clear\n        stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== \"clear\") {\n          return true;\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["STAGE_WIDTH","STAGE_HEIGHT","createStage","Array","from","fill","checkCollision","player","stage","x","moveX","y","moveY","tetromino","length","pos"],"sources":["/Users/heebeumkang/react-tetris/src/_gameHelpers.js"],"sourcesContent":["export const STAGE_WIDTH = 12;\nexport const STAGE_HEIGHT = 20;\n\nexport const createStage = () =>\n  Array.from(Array(STAGE_HEIGHT), () =>\n    new Array(STAGE_WIDTH).fill([0, \"clear\"])\n  );\n\nexport const checkCollision = (player, stage, { x: moveX, y: moveY }) => {\n  for (let y = 0; y < player.tetromino.length; y += 1) {\n    for (let x = 0; x < player.tetromino[y].length; x += 1) {\n      // 1. Check that we're on an actual Tetromino cell\n      if (player.tetromino[y][x] !== 0) {\n        if (\n          // 2. Check that our move is inside the game areas height (y)\n          // we shouldn't go through the bottom of the play area\n          !stage[y + player.pos.y + moveY] ||\n          // 3. Check that our move is inside the game areas width (x)\n          !stage[y + player.pos.y + moveY][x + player.pos.x + moveX] ||\n          // 4. Check that the cell we're moving to isn't set to clear\n          stage[y + player.pos.y + moveY][x + player.pos.x + moveX][1] !== \"clear\"\n        ) {\n          return true;\n        }\n      }\n    }\n  }\n};\n"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG,EAAE;AAC7B,OAAO,MAAMC,YAAY,GAAG,EAAE;AAE9B,OAAO,MAAMC,WAAW,GAAG,MACzBC,KAAK,CAACC,IAAI,CAACD,KAAK,CAACF,YAAY,CAAC,EAAE,MAC9B,IAAIE,KAAK,CAACH,WAAW,CAAC,CAACK,IAAI,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,CAC1C;AAEH,OAAO,MAAMC,cAAc,GAAG,CAACC,MAAM,EAAEC,KAAK,WAA6B;EAAA,IAA3B;IAAEC,CAAC,EAAEC,KAAK;IAAEC,CAAC,EAAEC;EAAM,CAAC;EAClE,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAACM,SAAS,CAACC,MAAM,EAAEH,CAAC,IAAI,CAAC,EAAE;IACnD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,MAAM,CAACM,SAAS,CAACF,CAAC,CAAC,CAACG,MAAM,EAAEL,CAAC,IAAI,CAAC,EAAE;MACtD;MACA,IAAIF,MAAM,CAACM,SAAS,CAACF,CAAC,CAAC,CAACF,CAAC,CAAC,KAAK,CAAC,EAAE;QAChC;QACE;QACA;QACA,CAACD,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAG,CAACJ,CAAC,GAAGC,KAAK,CAAC;QAChC;QACA,CAACJ,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAG,CAACJ,CAAC,GAAGC,KAAK,CAAC,CAACH,CAAC,GAAGF,MAAM,CAACQ,GAAG,CAACN,CAAC,GAAGC,KAAK,CAAC;QAC1D;QACAF,KAAK,CAACG,CAAC,GAAGJ,MAAM,CAACQ,GAAG,CAACJ,CAAC,GAAGC,KAAK,CAAC,CAACH,CAAC,GAAGF,MAAM,CAACQ,GAAG,CAACN,CAAC,GAAGC,KAAK,CAAC,CAAC,CAAC,CAAC,KAAK,OAAO,EACxE;UACA,OAAO,IAAI;QACb;MACF;IACF;EACF;AACF,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}